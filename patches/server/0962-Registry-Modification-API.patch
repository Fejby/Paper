From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Potrebic <jake.m.potrebic@gmail.com>
Date: Sat, 25 Feb 2023 13:46:14 -0800
Subject: [PATCH] Registry Modification API

== AT ==
public net.minecraft.server.RegistryLayer STATIC_ACCESS
public net.minecraft.core.MappedRegistry validateWrite(Lnet/minecraft/resources/ResourceKey;)V

diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/LaunchEntryPointHandler.java b/src/main/java/io/papermc/paper/plugin/entrypoint/LaunchEntryPointHandler.java
index 6c0f2c315387734f8dd4a7eca633aa0a9856dd17..48bc745ca9632fc46b5f786ff570434702eb47f2 100644
--- a/src/main/java/io/papermc/paper/plugin/entrypoint/LaunchEntryPointHandler.java
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/LaunchEntryPointHandler.java
@@ -4,6 +4,8 @@ import io.papermc.paper.plugin.provider.PluginProvider;
 import io.papermc.paper.plugin.storage.BootstrapProviderStorage;
 import io.papermc.paper.plugin.storage.ProviderStorage;
 import io.papermc.paper.plugin.storage.ServerPluginProviderStorage;
+import it.unimi.dsi.fastutil.objects.Object2BooleanMap;
+import it.unimi.dsi.fastutil.objects.Object2BooleanOpenHashMap;
 import org.jetbrains.annotations.ApiStatus;
 
 import java.util.HashMap;
@@ -16,9 +18,11 @@ public class LaunchEntryPointHandler implements EntrypointHandler {
 
     public static final LaunchEntryPointHandler INSTANCE = new LaunchEntryPointHandler();
     private final Map<Entrypoint<?>, ProviderStorage<?>> storage = new HashMap<>();
+    private final Object2BooleanMap<Entrypoint<?>> enteredMap = new Object2BooleanOpenHashMap<>();
 
     LaunchEntryPointHandler() {
         this.populateProviderStorage();
+        this.enteredMap.defaultReturnValue(false);
     }
 
     // Utility
@@ -34,6 +38,7 @@ public class LaunchEntryPointHandler implements EntrypointHandler {
         }
 
         storage.enter();
+        this.enteredMap.put(entrypoint, true);
     }
 
     @Override
@@ -57,6 +62,10 @@ public class LaunchEntryPointHandler implements EntrypointHandler {
         return storage;
     }
 
+    public boolean hasEntered(Entrypoint<?> entrypoint) {
+        return this.enteredMap.getBoolean(entrypoint);
+    }
+
     // Reload only
     public void populateProviderStorage() {
         this.storage.put(Entrypoint.BOOTSTRAPPER, new BootstrapProviderStorage());
diff --git a/src/main/java/io/papermc/paper/plugin/storage/BootstrapProviderStorage.java b/src/main/java/io/papermc/paper/plugin/storage/BootstrapProviderStorage.java
index e5b70ff297febd936e64055b79f48712d65dbed9..a1b39750ab576e8d83826e8932547f81db8b22b2 100644
--- a/src/main/java/io/papermc/paper/plugin/storage/BootstrapProviderStorage.java
+++ b/src/main/java/io/papermc/paper/plugin/storage/BootstrapProviderStorage.java
@@ -15,6 +15,7 @@ import io.papermc.paper.plugin.provider.ProviderStatus;
 import io.papermc.paper.plugin.provider.ProviderStatusHolder;
 import io.papermc.paper.plugin.provider.configuration.PaperPluginMeta;
 import io.papermc.paper.plugin.provider.configuration.type.DependencyConfiguration;
+import io.papermc.paper.registry.PaperRegistryListenerManager;
 import org.slf4j.Logger;
 
 import java.util.ArrayList;
@@ -38,6 +39,7 @@ public class BootstrapProviderStorage extends SimpleProviderStorage<PluginBootst
                 try {
                     PluginProviderContext context = PluginProviderContextImpl.of(provider, PluginInitializerManager.instance().pluginDirectoryPath());
                     provided.bootstrap(context);
+                    provided.registryStuff(PaperRegistryListenerManager.INSTANCE.forPlugin(provider.getMeta()));
                     return true;
                 } catch (Exception e) {
                     LOGGER.error("Failed to run bootstrapper for %s. This plugin will not be loaded.".formatted(provider.getSource()), e);
diff --git a/src/main/java/io/papermc/paper/registry/PaperRegistries.java b/src/main/java/io/papermc/paper/registry/PaperRegistries.java
new file mode 100644
index 0000000000000000000000000000000000000000..8b7d4378e98af9c145e873d196da6eb6cf8348ee
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/PaperRegistries.java
@@ -0,0 +1,38 @@
+package io.papermc.paper.registry;
+
+import com.google.common.collect.ImmutableList;
+import io.papermc.paper.registry.entry.RegistryEntry;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.resources.ResourceKey;
+import org.bukkit.craftbukkit.generator.strucutre.CraftStructure;
+import org.bukkit.craftbukkit.generator.strucutre.CraftStructureType;
+
+import static io.papermc.paper.registry.entry.RegistryEntry.immutable;
+import static io.papermc.paper.registry.entry.RegistryEntry.immutableBuiltIn;
+
+public final class PaperRegistries {
+
+    static final List<RegistryEntry<?, ?>> REGISTRY_ENTRIES;
+    static {
+        REGISTRY_ENTRIES = ImmutableList.<RegistryEntry<?, ?>>builder()
+            // built-ins
+            .add(immutableBuiltIn(RegistryKey2.STRUCTURE_TYPE, Registries.STRUCTURE_TYPE, CraftStructureType::new))
+
+            // data-drivens
+            .add(immutable(RegistryKey2.STRUCTURE, Registries.STRUCTURE, CraftStructure::new).delay())
+            .build();
+    }
+
+    static final Map<RegistryKey2<?>, RegistryEntry<?, ?>> BY_REGISTRY_KEY = REGISTRY_ENTRIES.stream()
+        .collect(Collectors.toMap(RegistryEntry::key, Function.identity()));
+
+    static final Map<ResourceKey<?>, RegistryEntry<?, ?>> BY_RESOURCE_KEY = REGISTRY_ENTRIES.stream()
+        .collect(Collectors.toMap(RegistryEntry::resourceKey, Function.identity()));
+
+    private PaperRegistries() {
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/PaperRegistryAccess.java b/src/main/java/io/papermc/paper/registry/PaperRegistryAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..d28f4eac59d2292a7bf19c5ca2b1feed829f9981
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/PaperRegistryAccess.java
@@ -0,0 +1,92 @@
+package io.papermc.paper.registry;
+
+import io.papermc.paper.registry.entry.RegistryEntry;
+import io.papermc.paper.registry.legacy.DelayedRegistry;
+import io.papermc.paper.registry.legacy.DelayedRegistryEntry;
+import java.util.IdentityHashMap;
+import java.util.Map;
+import java.util.function.BooleanSupplier;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.RegistryLayer;
+import org.bukkit.Keyed;
+import org.bukkit.Registry;
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+public class PaperRegistryAccess implements RegistryAccess {
+
+    private final Map<RegistryKey2<?>, Registry<?>> registries = new IdentityHashMap<>();
+
+    public static PaperRegistryAccess instance() {
+        return (PaperRegistryAccess) RegistryAccess.INSTANCE;
+    }
+
+    @SuppressWarnings("unchecked")
+    @Deprecated
+    @Override
+    public <T extends Keyed> @Nullable Registry<T> getRegistry(final Class<T> type) {
+        final @Nullable RegistryKey2<T> rKey = byType(type);
+        if (rKey == null) {
+            return null;
+        }
+        if (this.registries.containsKey(rKey)) {
+            return (Registry<T>) this.registries.get(rKey);
+        } else {
+            final @Nullable RegistryEntry<?, T> entry = (RegistryEntry<?, T>) PaperRegistries.BY_REGISTRY_KEY.get(rKey);
+            if (!(entry instanceof DelayedRegistryEntry<?, ?>)) {
+                return null;
+            }
+            return entry.createRegistry(null);
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public <T extends Keyed> Registry<T> getRegistry(final RegistryKey2<T> key) {
+        final @Nullable RegistryEntry<?, T> entry = (RegistryEntry<?, T>) PaperRegistries.BY_REGISTRY_KEY.get(key);
+        if (entry == null) {
+            throw new IllegalArgumentException(key + " is not a recognized key");
+        }
+        @Nullable Registry<T> registry = (Registry<T>) this.registries.get(key);
+        if (registry == null) {
+            if (entry instanceof RegistryEntry.BuiltIn<?,?> builtIn) { // provide built-ins as needed
+                registry = (Registry<T>) builtIn.createRegistry();
+                this.registries.put(entry.key(), registry);
+                return registry;
+            }
+            throw new IllegalArgumentException("You cannot access this registry: " + key + " yet!");
+        }
+        return registry;
+    }
+
+    @SuppressWarnings("unchecked")
+    public <M, T extends Keyed> void createRegistry(final net.minecraft.core.Registry<M> registry) {
+        final @Nullable RegistryEntry<M, T> entry = (RegistryEntry<M, T>) PaperRegistries.BY_RESOURCE_KEY.get(registry.key());
+        if (entry == null) { // not handled in API
+            return;
+        }
+        if (this.registries.containsKey(entry.key())) {
+            throw new IllegalArgumentException(registry.key() + " has already been created");
+        }
+        this.registries.put(entry.key(), entry.createRegistry(registry));
+    }
+
+    public net.minecraft.core.RegistryAccess getDelayedRegistryAccess() {
+        return MinecraftServer.getServer().registryAccess();
+    }
+
+    public BooleanSupplier delayedValidCheck() {
+        //noinspection ConstantValue
+        return () -> MinecraftServer.getServer() != null;
+    }
+
+    @SuppressWarnings("unchecked")
+    @Deprecated
+    static <T extends Keyed> @Nullable RegistryKey2<T> byType(final Class<T> type) {
+        for (final RegistryKey2<?> key : RegistryKey2.REGISTRY_KEYS) {
+            if (key.type().equals(type)) {
+                return (RegistryKey2<T>) key;
+            }
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/PaperRegistryBuilder.java b/src/main/java/io/papermc/paper/registry/PaperRegistryBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..5cae0cfc8b4d023f75b0ab22d7bd43312a58f645
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/PaperRegistryBuilder.java
@@ -0,0 +1,8 @@
+package io.papermc.paper.registry;
+
+import net.kyori.adventure.key.Keyed;
+
+public interface PaperRegistryBuilder<M, T extends Keyed> extends RegistryBuilder<T> {
+
+    M build();
+}
diff --git a/src/main/java/io/papermc/paper/registry/PaperRegistryListenerManager.java b/src/main/java/io/papermc/paper/registry/PaperRegistryListenerManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..509cff0345c9cd85d8f14d4aa889e2584738e249
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/PaperRegistryListenerManager.java
@@ -0,0 +1,128 @@
+package io.papermc.paper.registry;
+
+import com.google.common.base.Preconditions;
+import com.mojang.serialization.Lifecycle;
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.entrypoint.Entrypoint;
+import io.papermc.paper.plugin.entrypoint.LaunchEntryPointHandler;
+import io.papermc.paper.registry.entry.RegistryEntry;
+import io.papermc.paper.registry.event.FreezeRegistryEvent;
+import io.papermc.paper.registry.event.ModifyRegistryEvent;
+import java.util.ArrayList;
+import java.util.IdentityHashMap;
+import java.util.List;
+import java.util.Map;
+import net.minecraft.core.MappedRegistry;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.resources.ResourceLocation;
+import org.bukkit.Keyed;
+import org.bukkit.craftbukkit.CraftRegistry;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+public final class PaperRegistryListenerManager {
+
+    public static final PaperRegistryListenerManager INSTANCE = new PaperRegistryListenerManager();
+
+    private final Map<RegistryKey2<?>, List<RegisteredListener<RegistryListener.Freeze<?, ?>>>> freezes = new IdentityHashMap<>();
+    private final Map<RegistryKey2<?>, List<RegisteredListener<RegistryListener.Modification<?, ?>>>> modifications = new IdentityHashMap<>();
+
+    private PaperRegistryListenerManager() {
+    }
+
+    public RegistryListenerManager forPlugin(final PluginMeta pluginMeta) {
+        return new PluginRegistryListenerManager(pluginMeta);
+    }
+
+    private record RegisteredListener<L>(PluginMeta pluginMeta, L listener) {
+    }
+
+    public <M> M registerWithListeners(final Registry<M> registry, final String id, final M nms) {
+        return this.registerWithListeners(registry, new ResourceLocation(id), nms);
+    }
+
+    public <M> M registerWithListeners(final Registry<M> registry, final ResourceLocation loc, final M nms) {
+        return this.registerWithListeners(registry, ResourceKey.create(registry.key(), loc), nms);
+    }
+
+    public <M> M registerWithListeners(final Registry<M> registry, final ResourceKey<M> key, final M nms) {
+        return this.registerWithListeners(registry, key, nms, Lifecycle.stable());
+    }
+
+    @SuppressWarnings("unchecked")
+    public <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> M registerWithListeners(final Registry<M> registry, final ResourceKey<M> key, final M nms, final Lifecycle lifecycle) {
+        Preconditions.checkState(LaunchEntryPointHandler.INSTANCE.hasEntered(Entrypoint.BOOTSTRAPPER), registry.key() + " tried to run modification listeners before bootstrappers have been called"); // verify that bootstrappers have been called
+        final @Nullable RegistryEntry<M, T> entry = (RegistryEntry<M, T>) PaperRegistries.BY_RESOURCE_KEY.get(registry.key());
+        if (!(entry instanceof RegistryEntry.Modifiable<?, ?, ?>) || !this.modifications.containsKey(entry.key())) {
+            ((net.minecraft.core.WritableRegistry<M>) registry).register(key, nms, lifecycle);
+            return nms;
+        }
+        final CraftRegistry<T, M> craftRegistry = (CraftRegistry<T, M>) PaperRegistryAccess.instance().getRegistry(entry.key());
+        final RegistryEntry.Modifiable<M, T, B> modifiableEntry = (RegistryEntry.Modifiable<M, T, B>) entry;
+        final B builder = modifiableEntry.fillBuilder(CraftNamespacedKey.fromMinecraft(key.location()), nms);
+        return this.registerWithListeners(registry, craftRegistry.view, modifiableEntry, key, nms, builder, lifecycle);
+    }
+
+    @SuppressWarnings("unchecked")
+    public <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> M registerWithListeners(final Registry<M> registry, final RegistryView<T> registryView, final RegistryEntry.Modifiable<M, T, B> entry, final ResourceKey<M> key, final @Nullable M oldNms, final B builder, final Lifecycle lifecycle) {
+        final ModifyRegistryEvent<T, B> event = entry.createModifyEvent(builder, registryView);
+        if (this.modifications.containsKey(entry.key())) {
+            this.modifications.get(entry.key()).forEach(listener -> {
+                // TODO exception catching
+                ((RegistryListener.Modification<T, B>) listener.listener()).beforeRegister(event);
+            });
+        }
+        if (oldNms != null) {
+            ((MappedRegistry<M>) registry).clearIntrusiveHolder(oldNms);
+        }
+        final M newNms = event.currentBuilder().build();
+        ((net.minecraft.core.WritableRegistry<M>) registry).register(key, newNms, lifecycle);
+        return newNms;
+    }
+
+    @SuppressWarnings("unchecked")
+    public <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> void runFreezeListeners(final ResourceKey<? extends Registry<M>> resourceKey) {
+        final @Nullable RegistryEntry<M, T> entry = (RegistryEntry<M, T>) PaperRegistries.BY_RESOURCE_KEY.get(resourceKey);
+        if (!(entry instanceof RegistryEntry.Writable<M,?,?> writable) || !this.freezes.containsKey(entry.key())) {
+            return;
+        }
+        final FreezeRegistryEvent<T, B> event = ((RegistryEntry.Writable<M, T, B>)writable).createFreezeEvent((PaperWritableRegistry<M, T, B>) PaperRegistryAccess.INSTANCE.getRegistry(entry.key()));
+        this.freezes.get(entry.key()).forEach(rl -> {
+            // TODO exception catching
+            ((RegistryListener.Freeze<T, B>) rl.listener()).beforeFreeze(event);
+        });
+
+        // no listeners should run after being frozen
+        this.freezes.remove(entry.key());
+        this.modifications.remove(entry.key());
+
+    }
+
+    private final class PluginRegistryListenerManager implements RegistryListenerManager {
+
+        private final PluginMeta pluginMeta;
+
+        private PluginRegistryListenerManager(final PluginMeta pluginMeta) {
+            this.pluginMeta = pluginMeta;
+        }
+
+        @Override
+        public <T extends Keyed, B extends RegistryBuilder<T>> void registerFreezeListener(final RegistryKey2<T> registryKey, final RegistryListener.Freeze<T, B> listener) {
+            if (PaperRegistries.BY_REGISTRY_KEY.get(registryKey) instanceof RegistryEntry.Writable<?,?,?>) {
+                PaperRegistryListenerManager.this.freezes.computeIfAbsent(registryKey, ignored -> new ArrayList<>()).add(new RegisteredListener<>(this.pluginMeta, listener));
+            } else {
+                throw new IllegalArgumentException(registryKey + " does not support freeze listeners");
+            }
+        }
+
+        @Override
+        public <T extends Keyed, B extends RegistryBuilder<T>> void registerModificationListener(final RegistryKey2<T> registryKey, final RegistryListener.Modification<T, B> listener) {
+            if (PaperRegistries.BY_REGISTRY_KEY.get(registryKey) instanceof RegistryEntry.Modifiable<?,?,?>) {
+                PaperRegistryListenerManager.this.modifications.computeIfAbsent(registryKey, ignored -> new ArrayList<>()).add(new RegisteredListener<>(this.pluginMeta, listener));
+            } else {
+                throw new IllegalArgumentException(registryKey + " does not support modification listeners");
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/PaperWritableRegistry.java b/src/main/java/io/papermc/paper/registry/PaperWritableRegistry.java
new file mode 100644
index 0000000000000000000000000000000000000000..af6e86db8f589f6494199960469ef774b0b1e0a9
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/PaperWritableRegistry.java
@@ -0,0 +1,48 @@
+package io.papermc.paper.registry;
+
+import com.mojang.serialization.Lifecycle;
+import io.papermc.paper.registry.entry.RegistryEntry;
+import io.papermc.paper.registry.event.ModifiableRegistryView;
+import io.papermc.paper.registry.event.PaperModifiableRegistryView;
+import java.util.function.Consumer;
+import net.minecraft.core.MappedRegistry;
+import net.minecraft.resources.ResourceKey;
+import org.bukkit.Keyed;
+import org.bukkit.NamespacedKey;
+import org.bukkit.craftbukkit.CraftRegistry;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+public abstract class PaperWritableRegistry<M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> extends CraftRegistry<T, M> {
+
+    private final RegistryEntry.Writable<M, T, B> entry;
+    private final MappedRegistry<M> registry;
+    public final ModifiableRegistryView<T, B> modifiableView;
+
+    public PaperWritableRegistry(final RegistryEntry.Writable<M, T, B> entry, final MappedRegistry<M> registry) {
+        super(registry, null);
+        this.entry = entry;
+        this.registry = registry;
+        this.modifiableView = new PaperModifiableRegistryView<>(this.registry, this);
+    }
+
+    public void register(final NamespacedKey key, final Consumer<? super B> value) {
+        final ResourceKey<M> resourceKey = ResourceKey.create(this.registry.key(), CraftNamespacedKey.toMinecraft(key));
+        this.registry.validateWrite(resourceKey);
+        final B builder = this.newBuilder(key);
+        value.accept(builder);
+        PaperRegistryListenerManager.INSTANCE.registerWithListeners(this.registry, this.view, this.entry, resourceKey, null, builder, Lifecycle.experimental());
+    }
+
+    @Override
+    public final @Nullable T createBukkit(final NamespacedKey namespacedKey, final @Nullable M minecraft) {
+        if (minecraft == null) {
+            return null;
+        }
+        return this.minecraftToBukkit(namespacedKey, minecraft);
+    }
+
+    public abstract T minecraftToBukkit(NamespacedKey namespacedKey, M minecraft);
+
+    protected abstract B newBuilder(NamespacedKey key);
+}
diff --git a/src/main/java/io/papermc/paper/registry/SimplePaperWritableRegistry.java b/src/main/java/io/papermc/paper/registry/SimplePaperWritableRegistry.java
new file mode 100644
index 0000000000000000000000000000000000000000..2a047101f644e563db5f29e64a1d014b71c3e80b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/SimplePaperWritableRegistry.java
@@ -0,0 +1,31 @@
+package io.papermc.paper.registry;
+
+import io.papermc.paper.registry.entry.RegistryEntry;
+import java.util.function.BiFunction;
+import java.util.function.Function;
+import net.minecraft.core.MappedRegistry;
+import net.minecraft.core.Registry;
+import org.bukkit.Keyed;
+import org.bukkit.NamespacedKey;
+
+public final class SimplePaperWritableRegistry<M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> extends PaperWritableRegistry<M, T, B> {
+
+    private final Function<NamespacedKey, B> newBuilder;
+    private final BiFunction<NamespacedKey, M, T> minecraftToBukkit;
+
+    public SimplePaperWritableRegistry(final RegistryEntry.Writable<M, T, B> entry, final Registry<M> nmsRegistry, final Function<NamespacedKey, B> newBuilder, final BiFunction<NamespacedKey, M, T> minecraftToBukkit) {
+        super(entry, (MappedRegistry<M>) nmsRegistry);
+        this.newBuilder = newBuilder;
+        this.minecraftToBukkit = minecraftToBukkit;
+    }
+
+    @Override
+    public T minecraftToBukkit(final NamespacedKey namespacedKey, final M minecraft) {
+        return this.minecraftToBukkit.apply(namespacedKey, minecraft);
+    }
+
+    @Override
+    public B newBuilder(final NamespacedKey key) {
+        return this.newBuilder.apply(key);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/entry/ImmutableRegistryEntry.java b/src/main/java/io/papermc/paper/registry/entry/ImmutableRegistryEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..121047006929e2c5ea6a1438adfb7ce8b97ca7de
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/entry/ImmutableRegistryEntry.java
@@ -0,0 +1,48 @@
+package io.papermc.paper.registry.entry;
+
+import com.google.common.base.Preconditions;
+import io.papermc.paper.registry.RegistryKey2;
+import java.util.function.BiFunction;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.server.RegistryLayer;
+import org.bukkit.Keyed;
+import org.bukkit.NamespacedKey;
+import org.bukkit.craftbukkit.CraftRegistry;
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+public class ImmutableRegistryEntry<M, T extends Keyed> implements RegistryEntry<M, T> {
+
+    private final RegistryKey2<T> key;
+    private final ResourceKey<? extends Registry<M>> resourceKey;
+    protected final BiFunction<NamespacedKey, M, T> minecraftToBukkit;
+
+    public ImmutableRegistryEntry(final RegistryKey2<T> key, final ResourceKey<? extends Registry<M>> resourceKey, final BiFunction<NamespacedKey, M, T> minecraftToBukkit) {
+        this.key = key;
+        this.resourceKey = resourceKey;
+        this.minecraftToBukkit = minecraftToBukkit;
+    }
+
+    @Override
+    public RegistryKey2<T> key() {
+        return this.key;
+    }
+
+    @Override
+    public ResourceKey<? extends Registry<M>> resourceKey() {
+        return this.resourceKey;
+    }
+
+    @Override
+    public org.bukkit.Registry<T> createRegistry(final @Nullable Registry<M> registry) {
+        Preconditions.checkState(registry != null, "Cannot access " + this.resourceKey() + " yet");
+        return new CraftRegistry<>(registry, this.minecraftToBukkit);
+    }
+
+    public static class BuiltIn<M, T extends Keyed> extends ImmutableRegistryEntry<M, T> implements RegistryEntry.BuiltIn<M, T> {
+
+        public BuiltIn(final RegistryKey2<T> key, final ResourceKey<? extends Registry<M>> resourceKey, final BiFunction<NamespacedKey, M, T> minecraftToBukkit) {
+            super(key, resourceKey, minecraftToBukkit);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/entry/ModifiableRegistryEntry.java b/src/main/java/io/papermc/paper/registry/entry/ModifiableRegistryEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..4fa1acae75633a7e9601f6ef8388bf7d10be8304
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/entry/ModifiableRegistryEntry.java
@@ -0,0 +1,40 @@
+package io.papermc.paper.registry.entry;
+
+import io.papermc.paper.registry.PaperRegistryBuilder;
+import io.papermc.paper.registry.RegistryKey2;
+import io.papermc.paper.registry.RegistryView;
+import io.papermc.paper.registry.event.SimpleModifyRegistryEvent;
+import io.papermc.paper.registry.event.ModifyRegistryEvent;
+import java.util.function.BiFunction;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceKey;
+import org.bukkit.Keyed;
+import org.bukkit.NamespacedKey;
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+public class ModifiableRegistryEntry<M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> extends ImmutableRegistryEntry<M, T> implements RegistryEntry.Modifiable<M, T, B> {
+
+    protected final BiFunction<NamespacedKey, ? super @Nullable M, B> newBuilder;
+
+    ModifiableRegistryEntry(final RegistryKey2<T> key, final ResourceKey<? extends Registry<M>> resourceKey, final BiFunction<NamespacedKey, M, T> minecraftToBukkit, final BiFunction<NamespacedKey, ? super @Nullable M, B> newBuilder) {
+        super(key, resourceKey, minecraftToBukkit);
+        this.newBuilder = newBuilder;
+    }
+
+    @Override
+    public ModifyRegistryEvent<T, B> createModifyEvent(final B initialBuilder, final RegistryView<T> view) {
+        return new SimpleModifyRegistryEvent<>(initialBuilder, this.key(), view);
+    }
+
+    @Override
+    public B fillBuilder(final NamespacedKey key, final M nms) {
+        return this.newBuilder.apply(key, nms);
+    }
+
+    public static class BuiltIn<M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> extends ModifiableRegistryEntry<M, T, B> implements RegistryEntry.BuiltIn<M, T> {
+
+        public BuiltIn(final RegistryKey2<T> key, final ResourceKey<? extends Registry<M>> resourceKey, final BiFunction<NamespacedKey, M, T> minecraftToBukkit, final BiFunction<NamespacedKey, ? super @Nullable M, B> newBuilder) {
+            super(key, resourceKey, minecraftToBukkit, newBuilder);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/entry/RegistryEntry.java b/src/main/java/io/papermc/paper/registry/entry/RegistryEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..4e25fe9eb33866ba5741fa4cd0b1a6ffd28918ee
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/entry/RegistryEntry.java
@@ -0,0 +1,86 @@
+package io.papermc.paper.registry.entry;
+
+import com.google.common.base.Preconditions;
+import io.papermc.paper.registry.PaperRegistryBuilder;
+import io.papermc.paper.registry.PaperWritableRegistry;
+import io.papermc.paper.registry.RegistryKey2;
+import io.papermc.paper.registry.RegistryView;
+import io.papermc.paper.registry.event.FreezeRegistryEvent;
+import io.papermc.paper.registry.event.ModifyRegistryEvent;
+import io.papermc.paper.registry.legacy.DelayedRegistryEntry;
+import java.util.function.BiFunction;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.server.RegistryLayer;
+import org.bukkit.Keyed;
+import org.bukkit.NamespacedKey;
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+public interface RegistryEntry<M, T extends Keyed> {
+
+    ResourceKey<? extends Registry<M>> resourceKey();
+
+    RegistryKey2<T> key();
+
+    org.bukkit.Registry<T> createRegistry(@Nullable Registry<M> registry);
+
+    @Deprecated
+    default RegistryEntry<M, T> delay() {
+        Preconditions.checkState(!(this instanceof RegistryEntry.BuiltIn<M,T>), "Cannot delay a built-in registry");
+        return new DelayedRegistryEntry<>(this);
+    }
+
+    interface BuiltIn<M, T extends Keyed> extends RegistryEntry<M, T> {
+
+        default org.bukkit.Registry<T> createRegistry() {
+            return this.createRegistry(RegistryLayer.STATIC_ACCESS.registryOrThrow(this.resourceKey()));
+        }
+    }
+
+    interface Modifiable<M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> extends RegistryEntry<M, T> {
+
+        ModifyRegistryEvent<T, B> createModifyEvent(B initialBuilder, RegistryView<T> view);
+
+        B fillBuilder(NamespacedKey key, M nms);
+    }
+
+    interface Writable<M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> extends Modifiable<M, T, B> {
+
+        @Override
+        PaperWritableRegistry<M, T, B> createRegistry(@Nullable Registry<M> nmsRegistry);
+
+        FreezeRegistryEvent<T, B> createFreezeEvent(PaperWritableRegistry<M, T, B> registry);
+
+        interface BuiltIn<M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> extends Writable<M, T, B>, RegistryEntry.BuiltIn<M, T> {
+
+            @Override
+            default PaperWritableRegistry<M, T, B> createRegistry() {
+                return this.createRegistry(RegistryLayer.STATIC_ACCESS.registryOrThrow(this.resourceKey()));
+            }
+        }
+    }
+
+    static <M, T extends Keyed> RegistryEntry<M, T> immutable(final RegistryKey2<T> key, final ResourceKey<? extends Registry<M>> resourceKey, final BiFunction<NamespacedKey, M, T> minecraftToBukkit) {
+        return new ImmutableRegistryEntry<>(key, resourceKey, minecraftToBukkit);
+    }
+
+    static <M, T extends Keyed> RegistryEntry<M, T> immutableBuiltIn(final RegistryKey2<T> key, final ResourceKey<? extends Registry<M>> resourceKey, final BiFunction<NamespacedKey, M, T> minecraftToBukkit) {
+        return new ImmutableRegistryEntry.BuiltIn<>(key, resourceKey, minecraftToBukkit);
+    }
+
+    static <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> RegistryEntry<M, T> modifiable(final RegistryKey2<T> key, final ResourceKey<? extends Registry<M>> resourceKey, final BiFunction<NamespacedKey, M, T> minecraftToBukkit, final BiFunction<NamespacedKey, @Nullable M, B> newBuilder) {
+        return new ModifiableRegistryEntry<>(key, resourceKey, minecraftToBukkit, newBuilder);
+    }
+
+    static <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> RegistryEntry<M, T> modifiableBuiltIn(final RegistryKey2<T> key, final ResourceKey<? extends Registry<M>> resourceKey, final BiFunction<NamespacedKey, M, T> minecraftToBukkit, final BiFunction<NamespacedKey, @Nullable M, B> newBuilder) {
+        return new ModifiableRegistryEntry.BuiltIn<>(key, resourceKey, minecraftToBukkit, newBuilder);
+    }
+
+    static <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> RegistryEntry<M, T> writable(final RegistryKey2<T> key, final ResourceKey<? extends Registry<M>> resourceKey, final BiFunction<NamespacedKey, M, T> minecraftToBukkit, final BiFunction<NamespacedKey, @Nullable M, B> newBuilder) {
+        return new WritableRegistryEntry<>(key,resourceKey, minecraftToBukkit, newBuilder);
+    }
+
+    static <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> RegistryEntry<M, T> writableBuiltIn(final RegistryKey2<T> key, final ResourceKey<? extends Registry<M>> resourceKey, final BiFunction<NamespacedKey, M, T> minecraftToBukkit, final BiFunction<NamespacedKey, @Nullable M, B> newBuilder) {
+        return new WritableRegistryEntry.BuiltIn<>(key,resourceKey, minecraftToBukkit, newBuilder);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/entry/WritableRegistryEntry.java b/src/main/java/io/papermc/paper/registry/entry/WritableRegistryEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..5a6d402a7088059cc895d8221a026ffd2b20ff21
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/entry/WritableRegistryEntry.java
@@ -0,0 +1,45 @@
+package io.papermc.paper.registry.entry;
+
+import com.google.common.base.Preconditions;
+import io.papermc.paper.registry.PaperRegistryBuilder;
+import io.papermc.paper.registry.PaperWritableRegistry;
+import io.papermc.paper.registry.RegistryKey2;
+import io.papermc.paper.registry.SimplePaperWritableRegistry;
+import io.papermc.paper.registry.event.FreezeRegistryEvent;
+import io.papermc.paper.registry.event.SimpleFreezeRegistryEvent;
+import java.util.function.BiFunction;
+import java.util.function.Function;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceKey;
+import org.bukkit.Keyed;
+import org.bukkit.NamespacedKey;
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+public class WritableRegistryEntry<M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> extends ModifiableRegistryEntry<M, T, B> implements RegistryEntry.Writable<M, T, B> {
+
+    protected WritableRegistryEntry(final RegistryKey2<T> key, final ResourceKey<? extends Registry<M>> resourceKey, final BiFunction<NamespacedKey, M, T> minecraftToBukkit, final BiFunction<NamespacedKey, ? super @Nullable M, B> newBuilder) {
+        super(key, resourceKey, minecraftToBukkit, newBuilder);
+    }
+
+    @Override
+    public PaperWritableRegistry<M, T, B> createRegistry(final @Nullable Registry<M> registry) {
+        Preconditions.checkState(registry != null, "Cannot access " + this.resourceKey() + " yet");
+        return new SimplePaperWritableRegistry<>(this, registry, this.passNullNmsObject(this.newBuilder), this.minecraftToBukkit);
+    }
+
+    @Override
+    public FreezeRegistryEvent<T, B> createFreezeEvent(final PaperWritableRegistry<M, T, B> registry) {
+        return new SimpleFreezeRegistryEvent<>(this.key(), registry.modifiableView);
+    }
+
+    protected Function<NamespacedKey, B> passNullNmsObject(final BiFunction<NamespacedKey, ? super @Nullable M, B> biFunction) {
+        return t -> biFunction.apply(t, null);
+    }
+
+    public static class BuiltIn<M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> extends WritableRegistryEntry<M, T, B> implements RegistryEntry.Writable.BuiltIn<M, T, B> {
+
+        public BuiltIn(final RegistryKey2<T> key, final ResourceKey<? extends Registry<M>> resourceKey, final BiFunction<NamespacedKey, M, T> minecraftToBukkit, final BiFunction<NamespacedKey, ? super @Nullable M, B> newBuilder) {
+            super(key, resourceKey, minecraftToBukkit, newBuilder);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/entry/package-info.java b/src/main/java/io/papermc/paper/registry/entry/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..e4c94d6860e0f5b643cde1ded20b5503c02a4866
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/entry/package-info.java
@@ -0,0 +1,5 @@
+@DefaultQualifier(NonNull.class)
+package io.papermc.paper.registry.entry;
+
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
diff --git a/src/main/java/io/papermc/paper/registry/event/PaperModifiableRegistryView.java b/src/main/java/io/papermc/paper/registry/event/PaperModifiableRegistryView.java
new file mode 100644
index 0000000000000000000000000000000000000000..9987866483457d0a71a6d3fc3534570d4fd8f6f6
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/event/PaperModifiableRegistryView.java
@@ -0,0 +1,30 @@
+package io.papermc.paper.registry.event;
+
+import io.papermc.paper.registry.PaperRegistryBuilder;
+import io.papermc.paper.registry.PaperWritableRegistry;
+import java.util.function.BiFunction;
+import java.util.function.Consumer;
+import net.kyori.adventure.key.Key;
+import net.kyori.adventure.key.Keyed;
+import net.minecraft.core.Registry;
+import org.bukkit.NamespacedKey;
+
+public class PaperModifiableRegistryView<M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> extends PaperRegistryView<M, T> implements ModifiableRegistryView<T, B> {
+
+    private final PaperWritableRegistry<M, ? super T, B> writableRegistry;
+
+    @SuppressWarnings("unchecked")
+    public PaperModifiableRegistryView(final Registry<M> registry, final PaperWritableRegistry<M, ? super T, B> writableRegistry) {
+        super(registry, (BiFunction<NamespacedKey, M, T>) convert(writableRegistry::minecraftToBukkit));
+        this.writableRegistry = writableRegistry;
+    }
+
+    @Override
+    public void register(final Key key, final Consumer<? super B> value) {
+        this.writableRegistry.register(key instanceof NamespacedKey ns ? ns : new NamespacedKey(key.namespace(), key.value()), value);
+    }
+
+    private static <M, T> BiFunction<NamespacedKey, M, T> convert(final BiFunction<NamespacedKey, M, T> original) {
+        return original;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/event/PaperRegistryView.java b/src/main/java/io/papermc/paper/registry/event/PaperRegistryView.java
new file mode 100644
index 0000000000000000000000000000000000000000..b92b673abef26fffec1c007a728f2fedf55e7197
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/event/PaperRegistryView.java
@@ -0,0 +1,63 @@
+package io.papermc.paper.registry.event;
+
+import com.google.common.collect.Iterators;
+import io.papermc.paper.registry.RegistryView;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+import java.util.function.BiFunction;
+import net.kyori.adventure.key.Key;
+import net.kyori.adventure.key.Keyed;
+import net.minecraft.core.MappedRegistry;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceLocation;
+import org.bukkit.NamespacedKey;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+public class PaperRegistryView<M, T extends Keyed> implements RegistryView<T> {
+
+    protected final MappedRegistry<M> registry;
+    private final BiFunction<? super Key, M, T> minecraftToBukkit;
+
+    public PaperRegistryView(final Registry<M> registry, final BiFunction<NamespacedKey, M, T> minecraftToBukkit) {
+        this.registry = (MappedRegistry<M>) registry;
+        this.minecraftToBukkit = convert(minecraftToBukkit);
+    }
+
+    @Override
+    public T get(final Key key) {
+        final @Nullable M value = this.registry.beforeFrozenView().get(new ResourceLocation(key.namespace(), key.value()));
+        if (value == null) {
+            return null;
+        }
+        
+        return this.minecraftToBukkit.apply(key, value);
+    }
+
+    @Override
+    public T getOrThrow(final Key key) {
+        final @Nullable T value = this.get(key);
+        if (value == null) {
+            throw new NoSuchElementException("No value found for key " + key);
+        }
+        return value;
+    }
+
+    @Override
+    public T getOrDefault(final Key key, final T def) {
+        final @Nullable T value = this.get(key);
+        if (value == null) {
+            return def;
+        }
+        return value;
+    }
+
+    @Override
+    public Iterator<T> iterator() {
+        return Iterators.transform(this.registry.beforeFrozenView().entrySet().iterator(), input -> this.minecraftToBukkit.apply(CraftNamespacedKey.fromMinecraft(input.getKey()), input.getValue()));
+    }
+
+    private static <M, T extends Keyed> BiFunction<? super Key, M, T> convert(final BiFunction<NamespacedKey, M, T> original) {
+        return (key, m) -> original.apply(key instanceof NamespacedKey ns ? ns : new NamespacedKey(key.namespace(), key.value()), m);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/event/SimpleFreezeRegistryEvent.java b/src/main/java/io/papermc/paper/registry/event/SimpleFreezeRegistryEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..13f64d771e9bf237c2c7d1e0d3a35ccaa6ed2931
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/event/SimpleFreezeRegistryEvent.java
@@ -0,0 +1,11 @@
+package io.papermc.paper.registry.event;
+
+import io.papermc.paper.registry.RegistryBuilder;
+import io.papermc.paper.registry.RegistryKey2;
+import net.kyori.adventure.key.Keyed;
+
+public record SimpleFreezeRegistryEvent<T extends Keyed, B extends RegistryBuilder<T>>(
+    RegistryKey2<T> registryKey,
+    ModifiableRegistryView<T, B> registryView
+) implements FreezeRegistryEvent<T, B> {
+}
diff --git a/src/main/java/io/papermc/paper/registry/event/SimpleModifyRegistryEvent.java b/src/main/java/io/papermc/paper/registry/event/SimpleModifyRegistryEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..2f18b0be92ec41dc0207185fcde2c4cb0d6c7f43
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/event/SimpleModifyRegistryEvent.java
@@ -0,0 +1,15 @@
+package io.papermc.paper.registry.event;
+
+import io.papermc.paper.registry.RegistryBuilder;
+import io.papermc.paper.registry.RegistryKey2;
+import io.papermc.paper.registry.RegistryView;
+import io.papermc.paper.registry.event.ModifyRegistryEvent;
+import org.bukkit.Keyed;
+
+public record SimpleModifyRegistryEvent<T extends Keyed, B extends RegistryBuilder<T>>(
+    B currentBuilder,
+    RegistryKey2<T> registryKey,
+    RegistryView<T> registryView
+) implements ModifyRegistryEvent<T, B> {
+
+}
diff --git a/src/main/java/io/papermc/paper/registry/event/package-info.java b/src/main/java/io/papermc/paper/registry/event/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..14d2d9766b8dee763f220c397aba3ad432d02aaa
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/event/package-info.java
@@ -0,0 +1,5 @@
+@DefaultQualifier(NonNull.class)
+package io.papermc.paper.registry.event;
+
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
diff --git a/src/main/java/io/papermc/paper/registry/legacy/DelayedRegistry.java b/src/main/java/io/papermc/paper/registry/legacy/DelayedRegistry.java
new file mode 100644
index 0000000000000000000000000000000000000000..9d87a798c8f3d0c58eb1d0d0f3cd837874fc2281
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/legacy/DelayedRegistry.java
@@ -0,0 +1,47 @@
+package io.papermc.paper.registry.legacy;
+
+import java.util.Iterator;
+import java.util.function.BooleanSupplier;
+import java.util.function.Supplier;
+import org.bukkit.Keyed;
+import org.bukkit.NamespacedKey;
+import org.bukkit.Registry;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import oshi.util.Memoizer;
+
+/**
+ * This is to support the now-deprecated fields in {@link Registry} for
+ * data-driven registries.
+ */
+@Deprecated
+public final class DelayedRegistry<T extends Keyed> implements Registry<T> {
+    
+    private final Supplier<? extends Registry<T>> delegate;
+    private final BooleanSupplier validCheck;
+
+    public DelayedRegistry(final Supplier<? extends Registry<T>> delegate, final BooleanSupplier validCheck) {
+        this.delegate = Memoizer.memoize(delegate);
+        this.validCheck = validCheck;
+    }
+
+    private void checkValid() {
+        if (!this.validCheck.getAsBoolean()) {
+            throw new IllegalStateException("You are trying to access this registry too early!");
+        }
+    }
+
+    @Override
+    public @Nullable T get(final NamespacedKey key) {
+        this.checkValid();
+        return this.delegate.get().get(key);
+    }
+
+    
+    @Override
+    public Iterator<T> iterator() {
+        this.checkValid();
+        return this.delegate.get().iterator();
+    }
+
+
+}
diff --git a/src/main/java/io/papermc/paper/registry/legacy/DelayedRegistryEntry.java b/src/main/java/io/papermc/paper/registry/legacy/DelayedRegistryEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..17590d5f2e026daf0298e1e3d60a4bc729e1f4c2
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/legacy/DelayedRegistryEntry.java
@@ -0,0 +1,37 @@
+package io.papermc.paper.registry.legacy;
+
+import io.papermc.paper.registry.PaperRegistryAccess;
+import io.papermc.paper.registry.RegistryKey2;
+import io.papermc.paper.registry.entry.RegistryEntry;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceKey;
+import org.bukkit.Keyed;
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+@Deprecated
+public class DelayedRegistryEntry<M, T extends Keyed> implements RegistryEntry<M, T> {
+
+    private final RegistryEntry<M, T> delegate;
+
+    public DelayedRegistryEntry(final RegistryEntry<M, T> delegate) {
+        this.delegate = delegate;
+    }
+
+    @Override
+    public ResourceKey<? extends Registry<M>> resourceKey() {
+        return this.delegate.resourceKey();
+    }
+
+    @Override
+    public RegistryKey2<T> key() {
+        return this.delegate.key();
+    }
+
+    @Override
+    public org.bukkit.Registry<T> createRegistry(final @Nullable Registry<M> registry) {
+        if (registry == null && !PaperRegistryAccess.instance().delayedValidCheck().getAsBoolean()) {
+            return new DelayedRegistry<>(() -> this.delegate.createRegistry(PaperRegistryAccess.instance().getDelayedRegistryAccess().registryOrThrow(this.resourceKey())), PaperRegistryAccess.instance().delayedValidCheck());
+        }
+        return this.delegate.createRegistry(registry);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/legacy/package-info.java b/src/main/java/io/papermc/paper/registry/legacy/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..4396982af55872fafbfeaf8161ad6f392726c773
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/legacy/package-info.java
@@ -0,0 +1,5 @@
+@DefaultQualifier(NonNull.class)
+package io.papermc.paper.registry.legacy;
+
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
diff --git a/src/main/java/io/papermc/paper/registry/package-info.java b/src/main/java/io/papermc/paper/registry/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..0b80179ff90e085568d7ceafd9b17511789dc99b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/package-info.java
@@ -0,0 +1,5 @@
+@DefaultQualifier(NonNull.class)
+package io.papermc.paper.registry;
+
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
diff --git a/src/main/java/net/minecraft/core/MappedRegistry.java b/src/main/java/net/minecraft/core/MappedRegistry.java
index 6e6d9573115eeedef4cb24beac43f1bc96eebb49..befe662974bd3d6b4d0a2d69f9bfef46ec93986b 100644
--- a/src/main/java/net/minecraft/core/MappedRegistry.java
+++ b/src/main/java/net/minecraft/core/MappedRegistry.java
@@ -80,6 +80,14 @@ public class MappedRegistry<T> implements WritableRegistry<T> {
             return MappedRegistry.this.getTags().map(Pair::getSecond);
         }
     };
+    // Paper start
+    @Nullable
+    private Map<ResourceLocation, T> beforeFrozen = new HashMap<>(2048);
+    public Map<ResourceLocation, T> beforeFrozenView() {
+        Validate.validState(this.beforeFrozen != null, "Cannot get this after the registry is frozen");
+        return Collections.unmodifiableMap(this.beforeFrozen);
+    }
+    // Paper end
 
     public MappedRegistry(ResourceKey<? extends Registry<T>> key, Lifecycle lifecycle) {
         this(key, lifecycle, false);
@@ -166,6 +174,7 @@ public class MappedRegistry<T> implements WritableRegistry<T> {
         }
 
         this.lifecycles.put(object, lifecycle);
+        Objects.requireNonNull(this.beforeFrozen).put(resourceKey.location(), object); // Paper
         this.registryLifecycle = this.registryLifecycle.add(lifecycle);
         this.holdersInOrder = null;
         return reference;
@@ -339,6 +348,7 @@ public class MappedRegistry<T> implements WritableRegistry<T> {
             return this;
         } else {
             this.frozen = true;
+            this.beforeFrozen = null; // Paper
             this.byValue.forEach((value, entry) -> {
                 entry.bindValue(value);
             });
@@ -461,4 +471,12 @@ public class MappedRegistry<T> implements WritableRegistry<T> {
     public HolderLookup.RegistryLookup<T> asLookup() {
         return this.lookup;
     }
+    // Paper start
+    // used to clear intrusive holders from GameEvent, Item, Block, EntityType, and Fluid from unused instances of those types
+    public void clearIntrusiveHolder(T instance) {
+        if (this.unregisteredIntrusiveHolders != null) {
+            this.unregisteredIntrusiveHolders.remove(instance);
+        }
+    }
+    // Paper end
 }
diff --git a/src/main/java/net/minecraft/core/registries/BuiltInRegistries.java b/src/main/java/net/minecraft/core/registries/BuiltInRegistries.java
index ad802eb211f05f646159d7fc53f8a9427b46cb89..960759d598d3759148b85126d65453d971c49991 100644
--- a/src/main/java/net/minecraft/core/registries/BuiltInRegistries.java
+++ b/src/main/java/net/minecraft/core/registries/BuiltInRegistries.java
@@ -315,6 +315,7 @@ public class BuiltInRegistries {
     }
     public static void bootStrap(Runnable runnable) {
         // Paper end
+        REGISTRY.freeze(); // Paper - freeze main registry early
         createContents();
         runnable.run(); // Paper
         freeze();
@@ -334,6 +335,7 @@ public class BuiltInRegistries {
         REGISTRY.freeze();
 
         for(Registry<?> registry : REGISTRY) {
+            io.papermc.paper.registry.PaperRegistryListenerManager.INSTANCE.runFreezeListeners(registry.key()); // Paper
             registry.freeze();
         }
 
diff --git a/src/main/java/net/minecraft/resources/RegistryDataLoader.java b/src/main/java/net/minecraft/resources/RegistryDataLoader.java
index 38b3460acfb8f50be8f34a6b2bd04e9686472ea1..107c7c684524a1d383d3b2a47f2f82149b712a32 100644
--- a/src/main/java/net/minecraft/resources/RegistryDataLoader.java
+++ b/src/main/java/net/minecraft/resources/RegistryDataLoader.java
@@ -56,15 +56,20 @@ public class RegistryDataLoader {
         }).toList();
         RegistryOps.RegistryInfoLookup registryInfoLookup = createContext(baseRegistryManager, list);
         list.forEach((loader) -> {
+            io.papermc.paper.registry.PaperRegistryAccess.instance().createRegistry(loader.getFirst()); // Paper
             loader.getSecond().load(resourceManager, registryInfoLookup);
             // Paper start
             if (loader.getFirst().key() == Registries.CHAT_TYPE) {
-                Registry.register((Registry<ChatType>) loader.getFirst(), ChatType.RAW, new ChatType(new net.minecraft.network.chat.ChatTypeDecoration("%s", List.of(net.minecraft.network.chat.ChatTypeDecoration.Parameter.CONTENT), net.minecraft.network.chat.Style.EMPTY), new net.minecraft.network.chat.ChatTypeDecoration("%s", List.of(net.minecraft.network.chat.ChatTypeDecoration.Parameter.CONTENT), net.minecraft.network.chat.Style.EMPTY))); // CraftBukkit
+
+                final net.minecraft.network.chat.ChatType rawType = new net.minecraft.network.chat.ChatType(new net.minecraft.network.chat.ChatTypeDecoration("%s", java.util.List.of(net.minecraft.network.chat.ChatTypeDecoration.Parameter.CONTENT), net.minecraft.network.chat.Style.EMPTY), new net.minecraft.network.chat.ChatTypeDecoration("%s", java.util.List.of(net.minecraft.network.chat.ChatTypeDecoration.Parameter.CONTENT), net.minecraft.network.chat.Style.EMPTY));
+                // io.papermc.paper.registry.PaperRegistryListenerManager.INSTANCE.runModificationListeners(Registries.CHAT_TYPE, ) // TODO run modification listener
+                Registry.register((Registry<ChatType>) loader.getFirst(), ChatType.RAW, rawType); // CraftBukkit
             }
             // Paper end
         });
         list.forEach((loader) -> {
             Registry<?> registry = loader.getFirst();
+            io.papermc.paper.registry.PaperRegistryListenerManager.INSTANCE.runFreezeListeners(registry.key()); // Paper
 
             try {
                 registry.freeze();
@@ -144,7 +149,7 @@ public class RegistryDataLoader {
                     DataResult<E> dataResult = decoder.parse(registryOps, jsonElement);
                     E object = dataResult.getOrThrow(false, (error) -> {
                     });
-                    newRegistry.register(resourceKey, object, resource.isBuiltin() ? Lifecycle.stable() : dataResult.lifecycle());
+                    io.papermc.paper.registry.PaperRegistryListenerManager.INSTANCE.registerWithListeners(newRegistry, resourceKey, object, resource.isBuiltin() ? Lifecycle.stable() : dataResult.lifecycle()); // Paper
                 }
 
             } catch (Exception var20) {
diff --git a/src/main/java/net/minecraft/server/Bootstrap.java b/src/main/java/net/minecraft/server/Bootstrap.java
index a1192d1f6b99669f843e8d9a8928ff0e8c030559..237d0d9db8446e4353dbde03e0d9fa9facfba998 100644
--- a/src/main/java/net/minecraft/server/Bootstrap.java
+++ b/src/main/java/net/minecraft/server/Bootstrap.java
@@ -60,6 +60,7 @@ public class Bootstrap {
             if (BuiltInRegistries.REGISTRY.keySet().isEmpty()) {
                 throw new IllegalStateException("Unable to load registries");
             } else {
+                io.papermc.paper.plugin.entrypoint.LaunchEntryPointHandler.enterBootstrappers(); // Paper - Entrypoint for bootstrapping (before any registry is populated)
                 FireBlock.bootStrap();
                 ComposterBlock.bootStrap();
                 if (EntityType.getKey(EntityType.PLAYER) == null) {
@@ -72,7 +73,6 @@ public class Bootstrap {
                     // Paper start
                     BuiltInRegistries.bootStrap(() -> {
                         net.minecraft.core.Registry.register(net.minecraft.core.registries.BuiltInRegistries.MATERIAL_CONDITION, new net.minecraft.resources.ResourceLocation("paper", "bedrock_condition_source"), net.minecraft.data.worldgen.SurfaceRuleData.PaperBedrockConditionSource.CODEC.codec());
-                        io.papermc.paper.plugin.entrypoint.LaunchEntryPointHandler.enterBootstrappers(); // Paper - Entrypoint for bootstrapping
                     });
                     // Paper end
                     Bootstrap.wrapStreams();
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java b/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java
index 763f9d4740429840e78d3462277eb577d2d9f66a..e8462be9782374c5d380b9086c0ecaeef48f45da 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java
@@ -19,24 +19,17 @@ import org.bukkit.generator.structure.StructureType;
 
 public class CraftRegistry<B extends Keyed, M> implements Registry<B> {
 
-    public static <B extends Keyed> Registry<?> createRegistry(Class<B> bukkitClass, RegistryAccess registryHolder) {
-        if (bukkitClass == Structure.class) {
-            return new CraftRegistry<>(registryHolder.registryOrThrow(Registries.STRUCTURE), CraftStructure::new);
-        }
-        if (bukkitClass == StructureType.class) {
-            return new CraftRegistry<>(BuiltInRegistries.STRUCTURE_TYPE, CraftStructureType::new);
-        }
-
-        return null;
-    }
+    // Paper - replace
 
     private final Map<NamespacedKey, B> cache = new HashMap<>();
     private final net.minecraft.core.Registry<M> minecraftRegistry;
     private final BiFunction<NamespacedKey, M, B> minecraftToBukkit;
+    public final io.papermc.paper.registry.RegistryView<B> view; // Paper
 
     public CraftRegistry(net.minecraft.core.Registry<M> minecraftRegistry, BiFunction<NamespacedKey, M, B> minecraftToBukkit) {
         this.minecraftRegistry = minecraftRegistry;
         this.minecraftToBukkit = minecraftToBukkit;
+        this.view = new io.papermc.paper.registry.event.PaperRegistryView<>(this.minecraftRegistry, this.minecraftToBukkit);
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 1ca7a4aa8ccd34e2aedbe3963950ba3717c558b7..07622fdc9583928ce573e8940a5193e3c7123b52 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -276,7 +276,7 @@ public final class CraftServer implements Server {
     protected final DedicatedServer console;
     protected final DedicatedPlayerList playerList;
     private final Map<String, World> worlds = new LinkedHashMap<String, World>();
-    private final Map<Class<?>, Registry<?>> registries = new HashMap<>();
+    // private final Map<Class<?>, Registry<?>> registries = new HashMap<>(); // Paper - replace
     private YamlConfiguration configuration;
     private YamlConfiguration commandsConfiguration;
     private final Yaml yaml = new Yaml(new SafeConstructor());
@@ -2688,7 +2688,7 @@ public final class CraftServer implements Server {
 
     @Override
     public <T extends Keyed> Registry<T> getRegistry(Class<T> aClass) {
-        return (Registry<T>) this.registries.computeIfAbsent(aClass, key -> CraftRegistry.createRegistry(aClass, this.console.registryAccess()));
+        return io.papermc.paper.registry.RegistryAccess.INSTANCE.getRegistry(aClass); // Paper
     }
 
     @Deprecated
diff --git a/src/main/resources/META-INF/services/io.papermc.paper.registry.RegistryAccess b/src/main/resources/META-INF/services/io.papermc.paper.registry.RegistryAccess
new file mode 100644
index 0000000000000000000000000000000000000000..8a083d45004f82fc9c51c219fb20f34624adb501
--- /dev/null
+++ b/src/main/resources/META-INF/services/io.papermc.paper.registry.RegistryAccess
@@ -0,0 +1 @@
+io.papermc.paper.registry.PaperRegistryAccess
diff --git a/src/test/java/io/papermc/paper/registry/DummyRegistryAccess.java b/src/test/java/io/papermc/paper/registry/DummyRegistryAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..64fec4a1b81e51c790734c525fed886e31c30e67
--- /dev/null
+++ b/src/test/java/io/papermc/paper/registry/DummyRegistryAccess.java
@@ -0,0 +1,22 @@
+package io.papermc.paper.registry;
+
+import java.util.function.BooleanSupplier;
+import net.minecraft.core.RegistryAccess;
+import org.bukkit.support.AbstractTestingBase;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public class DummyRegistryAccess extends PaperRegistryAccess {
+
+    @Override
+    public RegistryAccess getDelayedRegistryAccess() {
+        return AbstractTestingBase.REGISTRY_CUSTOM;
+    }
+
+    @Override
+    public BooleanSupplier delayedValidCheck() {
+        //noinspection ConstantValue
+        return () -> AbstractTestingBase.REGISTRY_CUSTOM != null;
+    }
+}
diff --git a/src/test/java/io/papermc/paper/testing/DummyServer.java b/src/test/java/io/papermc/paper/testing/DummyServer.java
index f3db8d2875eaef86223da51b30e9dd722d417daa..929534b5963f3360478792498a6f70a40f339612 100644
--- a/src/test/java/io/papermc/paper/testing/DummyServer.java
+++ b/src/test/java/io/papermc/paper/testing/DummyServer.java
@@ -1,5 +1,6 @@
 package io.papermc.paper.testing;
 
+import io.papermc.paper.registry.RegistryAccess;
 import java.util.logging.Logger;
 import org.bukkit.Bukkit;
 import org.bukkit.Material;
@@ -55,7 +56,7 @@ public final class DummyServer {
 
         when(dummyServer.getRegistry(any())).thenAnswer(invocation -> {
             // LazyRegistry because the vanilla data hasn't been bootstrapped yet.
-            return new LazyRegistry(() -> CraftRegistry.createRegistry(invocation.getArgument(0, Class.class), AbstractTestingBase.REGISTRY_CUSTOM));
+            return RegistryAccess.INSTANCE.getRegistry(invocation.getArgument(0, Class.class));
         });
 
         final PluginManager pluginManager = new  io.papermc.paper.plugin.manager.PaperPluginManagerImpl(dummyServer, new SimpleCommandMap(dummyServer), null);
diff --git a/src/test/resources/META-INF/services/io.papermc.paper.registry.RegistryAccess b/src/test/resources/META-INF/services/io.papermc.paper.registry.RegistryAccess
new file mode 100644
index 0000000000000000000000000000000000000000..6c7526bbc7318f510f81f4073a158f7136017a56
--- /dev/null
+++ b/src/test/resources/META-INF/services/io.papermc.paper.registry.RegistryAccess
@@ -0,0 +1 @@
+io.papermc.paper.registry.DummyRegistryAccess
